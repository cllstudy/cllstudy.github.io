---
layout: post
title:  "测试文章"
date:    2021-04-09 15:02:40 
description: "这是个测试文章"
tag: 工具收藏
---

### 测试文章

Android 开发者们对于 Application 并不陌生。有的时候为避免内存泄漏，常常不直接使用 Context 而是通过其提供的 getApplicationContext() 确保拿到的是 Application 级别的 Context。而本次像通常一样，拿到的 Application 却是 null，到底是发生什么事了？
翻车了
先来回顾一下发生问题的代码。
为了避免内存泄漏，在对外提供的 Jar 包里不假思索地用了如下代码：
private DemoManager(Context context){
    mContext = context.getApplicationContext();
    if(DEBUG){
        mContext.getPackageName();
        ...
    }
}
复制代码
看似很平常的一个写法，在项目中应用该 Jar 包的时候 ，却发生了崩溃：mContext.getPackageName() 发生了空指针异常。
当看到是此处发生的 crash，属实有点意外、但也没时间多想，暂时将代码改成了这样。
private DemoManager(Context context){
    mContext = context.getApplicationContext();
    if(null == mContext){
        mContext = context;
    }
    if(DEBUG){
        mContext.getPackageName();
        ...
    }
 }
复制代码
事后有时间了，觉得有必要搞清楚，毕竟这有点颠覆作为一名 Android 老兵的认知。

Application Context 不应该都是先创建的嘛，为什么 Context 都有了 Application 却没有呢？

发生什么事了
尝试写了最小化 Demo 去复现，但是没成功，后来发现一般不会发生这样的问题，本次发生是因为运行的 App 比较特殊。
实际的代码在 TelephonyProvider  App 里添加了自定义的 ContentProvider，并在 query() 里使用了上述 Jar 包。而 TelephonyProvider  App 所依赖的 com.android.phone 系统进程会先启动，之后 TelephonyProvider 才会被加载到该进程。令人意想不到的是，对于 TelephonyProvider App 来说其 Application 一直是 null，并不是它自己的 Application，更不是 Phone Application。
所以，Demo 需要采用上述的特性才能复现。比如做 2 个 App，一个是查询 ContentProvider 的 App：Query App；另一个是供 ContentProvider 的App ：Provider App。

Query App 与 Provider App 在同一个进程 ，通过 android:process="XXX" 指定
Query App 先启动，并通过 ContentResolver 调用 Provider App 进行 query（ApplicationContext 为 null  和 Query App  调用 query 没有关系）

起初没注意到 TelephonyProvider 和 Phone 同进程的特性，所以 DEMO 怎么也复现不了。
接下来我们在 FW 里深入分析下。

为什么共用进程的 Provider App 拿不到 Application？

不按套路出牌啊
首先回顾下 ContentProvider  中 Context 是哪儿来的？
// frameworks/base/core/java/android/app/ActivityThread.java
private ContentProviderHolder installProvider(Context context...) {
    ContentProvider localProvider = null;
    IContentProvider provider;
    if (holder == null || holder.provider == null) {
        Context c = null;
        ApplicationInfo ai = info.applicationInfo;
        if (context.getPackageName().equals(ai.packageName)) {
            // 如果 Provider App 是独立进程，context 采用传递过来的 Application 参数
            c = context;
        } else if (mInitialApplication != null &&
                mInitialApplication.getPackageName().equals(ai.packageName)) {
            c = mInitialApplication;
        } else {
            try {
               // 反之调用 createPackageContext 创建特有的 Context
               c = context.createPackageContext(ai.packageName,
                            Context.CONTEXT_INCLUDE_CODE);
               }...
            }
            ...
            if (info.splitName != null) {
                try {
                    c = c.createContextForSplit(info.splitName);
                } catch (NameNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
            if (info.attributionTags != null && info.attributionTags.length > 0) {
                final String attributionTag = info.attributionTags[0];
                c = c.createAttributionContext(attributionTag);
            }

            try {
                // 这里的 c 就是传递给 ContentProvider 的实际 Context
                localProvider.attachInfo(c, info);
            ...
            }
        } 
        ...
}

作者：Jingle_zhang
链接：https://juejin.cn/post/7083300762901544968
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。